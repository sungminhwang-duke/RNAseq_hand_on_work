---
title: "RNA-seq analysis - Differentially Expressed Genes (DEGs) by DESeq2"
output: html_document
---

# Setup the required packages  
```{r}
rm(list = ls())

#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("DESeq2")
 
library(tidyverse)
library(ggplot2)
library(ggrepel)
library(RColorBrewer)
library(DESeq2)
library(pheatmap)
library(dendextend)

dir.create("Result_DEG")
dir.create("Result_Function")
```

# Input data
```{r}
# Read the count file containing all bio reps
mycount <- as.matrix(read.csv("Data_2_2021.csv", row.names="gene_id"))
dim(mycount)
class(mycount)
head(mycount, 2)

# Read the meta file 
coldata <- read.csv("Meta_2_2021.csv", row.names = 1)
dim(coldata)
class(coldata)
coldata <- coldata[,c("Strain", "Chemical")]

# Are they identical as they follow different orders?
all(rownames(coldata) == colnames(mycount))
# If needed, reorder the columns of the count matrix according to the order of Label in columnData
#mycount <- mycount[,rownames(coldata)]
#all(rownames(coldata) == colnames(mycount))
```

# Set an object for analysis
```{r}
dds.mydata <- DESeqDataSetFromMatrix(
  mycount,                      # Count matrix
  coldata,                      # metadata
  ~ Chemical)  # design formula

dds.mydata$Chemical <- relevel(dds.mydata$Chemical, ref = "none")
dds.mydata
slotNames(dds.mydata)
dds.mydata@design # Check your design for the comparison.
dds.mydata@colData
```

# DESeq2 Steps: 1) estimate size factors and normalization, 2) estimate dispersion parameters, and 3) DEG analysis
# 1) estimate size factors and normalization
```{r}
dds.mydata <- estimateSizeFactors(dds.mydata)
dds.mydata
sizeFactors(dds.mydata)
normalized_counts <- counts(dds.mydata, normalized=TRUE)
write.csv(normalized_counts, "Result_DEG/mydata1_norm.csv")

sizeFactors(dds.mydata) %>%
  as.data.frame %>%
  rownames_to_column -> mydf

colnames(mydf)[2] <- "sizefac"
mydf
ggplot(mydf, aes(rowname, sizefac)) + geom_point() + theme(axis.text.x = element_text(face="bold", color="blue", angle=45))
```

# 2) estimate dispersion parameters
```{r}
#Dispersion is a measure of spread or variability in the data.
#DESeq2 uses a specific measure of dispersion (α) related to the mean (μ) and variance of the data: Var = μ + α*μ^2. 
#DESeq2 dispersion estimates are inversely related to the mean and directly related to variance. Based on this relationship, the dispersion is higher for small mean counts and lower for large mean counts. The dispersion estimates for genes with the same mean will differ only based on their variance. Therefore, the dispersion estimates reflect the variance in gene expression for a given mean value.

dds.mydata <- estimateDispersions(dds.mydata)
dds.mydata
dds.mydata@dispersionFunction
alphas <- dispersions(dds.mydata) # Verify that the number of dispersion factors equals the number of genes
length(alphas) # The number of disperion factors
mcols(dds.mydata)
#baseMean:	  mean of normalized counts for all samples
#baseVar: 	  variance of normalized counts for all samples
#allZero: 	  all counts for a gene are zero
#dispGeneEst:	gene-wise estimates of dispersion
#dispFit: 	  fitted values of dispersion
#dispersion:	final estimate of dispersion
#dispIter:  	number of iterations
#dispOut:   	dispersion flagged as outlier
#dispMAP:   	maximum a posteriori estimate

#boxplot(log(dispersions(dds.mydata))) # Summarize the dispersion factors using a box plot
#plotDispEsts(dds.mydata) # Plot the dispersion estimates. The shrinkage method is applied to reduce false positives in the differential expression analysis.
```

# 3) DEG analysis
```{r}
# We can now conduct a differential expression analysis using the DESeq() function. 
ddsDE <- DESeq(dds.mydata)
ddsDE # Look at object
colSums(counts(ddsDE)) # Total number of raw counts per sample
raw.count <- colSums(counts(ddsDE)) %>%
  data.frame() %>%
  rownames_to_column(var="sample") %>%
  as_tibble()
ggplot(raw.count, aes(x=sample, y=.)) + geom_point() + theme(axis.text.x = element_text(face="bold", color="blue", angle=45))

colSums(counts(ddsDE, normalized = T)) # Total number of normalized counts per sample
norm.count <- colSums(counts(ddsDE, normalized = T)) %>%
  data.frame() %>%
  rownames_to_column(var="sample") %>%
  as_tibble()
ggplot(norm.count, aes(x=sample, y=.)) + geom_point() + theme(axis.text.x = element_text(face="bold", color="blue", angle=45))

results(ddsDE) # We can get the results for the differential expression analysis.
results(ddsDE, tidy = TRUE)
summary(results(ddsDE))

# Clustering: Regularized log transformation. The regularized log transform can be obtained using the rlog() function. Note that an important argument for this function is blind (TRUE by default). The default "blinds" the normalization to the design. This is very important so as to not bias the analyses (e.g. class discovery)
rld <- rlog(ddsDE, blind = TRUE)
rld.table <- assay(rld)
write.csv(rld.table, "Result_DEG/mydata1_norm_log2.csv") #edit the first column name as "Locus" in log2_norm_count.csv from your local folder
sampleDists <- dist( t( assay(rld) ) )
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste(coldata$rownames)
#rownames(sampleDistMatrix) <- paste(rld$Strain, rld$Chemical, sep="-")
#colnames(sampleDistMatrix) <- paste(rld$Strain, rld$Chemical, sep="-")
#colnames(sampleDistMatrix) <- NULL # Use this, if you want to remove the column name.
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
dev.print(pdf, 'Result_DEG/Fig1_heatmap.pdf', width = 10, height =12)

# Dendrogram of samples: showing strain & media of each sample. Hierarchical clustering using rlog transformation.
options(repr.plot.width = 9, repr.plot.height = 5)
plot(hclust(sampleDists, method = "complete"))
dev.print(pdf, 'Result_DEG/Fig2_dendrogram.pdf', width = 10, height =12)

# Principal Components Analysis (i.e., Color by condition): used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction).
# If two samples have similar levels of expression for the genes that contribute significantly to the variation represented by PC1, they will be plotted close together on the PC1 axis. 
plotPCA(rld, intgroup = c("Chemical"))
dev.print(pdf, 'Result_DEG/Fig3_PCA.pdf', width = 10, height =12)

# Here, you can compare two group of samples specified by the contrast. 
# If not, the default contrast would be the last term in your additive model design(dds).
coldata # none, Hopea
myres_EryVSnone <- results(ddsDE, contrast = c("Chemical", "Hopea", "none"))
myres_EryVSnone
myres_table_myres_EryVSnone <- myres_EryVSnone %>% # Make a result table
  data.frame() %>%
  rownames_to_column(var="Locus") %>%
  as_tibble()

myres_table_myres_EryVSnone_sig <- myres_table_myres_EryVSnone %>%
  filter(abs(log2FoldChange) > 1 , padj < 0.05)
colnames(myres_table_myres_EryVSnone_sig) <- c("gene", "baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj")
write.csv(myres_table_myres_EryVSnone_sig, "DEGs_list.csv")
```

# 4) Visualization - volcano plot
```{r}
# Volcano  plot (red if both padj < 0.05 and log2FC > 1)
#https://www.bioconductor.org/packages/release/bioc/vignettes/EnhancedVolcano/inst/doc/EnhancedVolcano.html

library(ggplot2)
x <- myres_table_myres_EryVSnone
x$expression = ifelse(x$padj < 0.05 & abs(x$log2FoldChange) > 1, 
                      ifelse(x$log2FoldChange > 1 ,'Up','Down'),'Stable')

p <- ggplot(data = x, 
            aes(x = log2FoldChange, 
                y = -log10(x$padj), 
                colour=expression,
                label = x$Locus)) +
  geom_point(alpha=0.4, size=2.5) +
  scale_color_manual(values=c("blue", "grey","red"))+
  xlim(c(-10, 10)) +
  geom_vline(xintercept=c(-1,1),lty=2,col="black",lwd=0.5) +
  geom_hline(yintercept = 1.301,lty=2,col="black",lwd=0.5) +
  labs(x="log2(fold change)",
       y="-log10 (adjusted P)",
       title="Differential expression")  +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5), 
        legend.position="right", 
        legend.title = element_blank(),
        text = element_text(size = 20))
p
dev.print(pdf, 'Result_DEG/Fig4_volcano_plot.pdf', width = 7, height =9)
```


# 5) Functional enrichment by a hypergeometric test - setup
```{r}
library(tidyverse)
library(reutils)
library(plyr)
library(ggplot2)

`%ni%` = Negate(`%in%`)
#this function converts genomes annotation files (.gff) from NCBI to a readable table
gff.parse <- function(x) {
  ids <- list()
  x %>% filter(type == "gene" | type == "CDS" | type == "tRNA" | type == "rRNA" ) -> x
  
  #if ("old_locus_tag" %in% colnames(x)) {
  if ("locus_tag" %in% colnames(x)) {
    for (i in 1:(nrow(x)-1)) {
      if (all(x[i,2:4] == x[i+1,2:4])) {
        vec <- data.frame("chr"=x[["seqnames"]][i],
                          "acc"= x[["protein_id"]][(i+1)], 
                          "locus_tag" = x[["locus_tag"]][i], 
                          "old_locus_tag" = x[["old_locus_tag"]][i], 
                          "length_nt"= x[["width"]][i], 
                          "start"= x[["start"]][i], 
                          "end"= x[["end"]][i],
                          "strand" = x[["strand"]][i],
                          "type"= x[["gene_biotype"]][i],
                          "annotation"= x[["product"]][(i+1)],
                          stringsAsFactors = F)
        ids[[i]] <- vec
      }}} 
  else if ("gene" %in% colnames(x)) {
    for (i in 1:(nrow(x)-1)) {
      if (all(x[i,2:4] == x[i+1,2:4])) {
        vec <- data.frame("chr"=x[["seqnames"]][i],
                          "acc"= x[["protein_id"]][(i+1)], 
                          "locus_tag" = x[["locus_tag"]][i], 
                          "gene_name" = x[["gene"]][i], 
                          "length_nt"= x[["width"]][i], 
                          "start"= x[["start"]][i], 
                          "end"= x[["end"]][i],
                          "strand" = x[["strand"]][i],
                          "type"= x[["gene_biotype"]][i],
                          "annotation"= x[["product"]][(i+1)],
                          stringsAsFactors = F)
        ids[[i]] <- vec
      }}}
  
  df <- bind_rows(ids)
  if (length(na.omit(unique(x[["protein_id"]]))) == length(na.omit(unique(df[["acc"]])))) {
    print("all protein ids accounted for")
  }
  return(df)
}
getNOG <- function(x, colname = "eggNOGs", sep = " ", factors = FALSE) {
  lis <- list()
  for (i in 1:length(x[[colname]])) {
    #vec <- c(capture.output(cat(unlist(str_extract_all(x[[colname]][i], "[a-zA-Z0-9]*@NOG")), sep = sep)))
    vec <- c(capture.output(cat(unlist(str_extract_all(x[[colname]][i], "[a-zA-Z0-9]*@")), sep = sep)))
    lis[[i]] <- vec
    column.names <- "NOGs"
  } 
  df <- as.data.frame(do.call(rbind, lis), stringsAsFactors = FALSE)
  colnames(df) <- column.names
  df <- cbind("query" = x[["query"]], df, "COG_category" = x[["COG Cat."]], "HMM_description" = x[["eggNOG HMM Desc."]])
  return(df)
}

#This function gets sequences based on your acc list
getseqs <- function(x, filename) {
  #x must be a vector of acc or gi numbers.
  require(reutils)
  path <- file.path(getwd(), filename)
  uid1 <- esearch(x, "protein", rettype = "uilist", usehistory = F)
  efetch(uid1, "protein", "fasta", "text", outfile = filename)
  print(paste("sequences can be found at ", path))
}

nogtest <- function(namelist,nogfile,pvalue, cutoff = 5) {
  #namelist is a vector of protein on gene names you wnat to test for enrichment
  #nogfile is the genome-wide GETNOG output
  #p-value is significance threshold desired
  #cutoff preset prevents functional categories with less than the designated number of genes/proteins being displayed 
  
  nogs <- nogfile[nogfile[["query"]] %in% namelist,]
  clust <-  table(nogs[["COG_category"]])
  resm <- matrix(0,length(clust),3) #create 0 matrix
  res <- data.frame(resm)  #make 0 df
  rownames(res) <- names(clust)
  colnames(res) <- c("probability", "expected","count")
  all <- table(nogfile[["COG_category"]][nogfile[["COG_category"]] %in% nogs[["COG_category"]]])
  tot <- sum(table(nogfile[["COG_category"]]))
  #print(tot); print(all); print(clust)
  for (i in 1:length(clust)){   #calc expected frequencies and pval by hypergeo and append to DF
    
    res[i,1] <- signif(phyper(clust[i], all[i], tot-all[i], nrow(nogs),lower.tail=F), digits = 4)
    res[i,2] <- signif(all[i]*(nrow(nogs)/tot), digits = 4)
    res[i,3] <- clust[i]
  }
  fin <- subset(res, probability <= pvalue & count >= cutoff)
  fin$COG_category <- rownames(fin)
  fin <- fin[, c("COG_category", "probability", "expected", "count")]
  return(fin)
}
#Use the following function to look at the genes in your cluster associated with a particular COG.
nogset= function(namelist,nogfile, cog.category) {
  subset(nogfile, is.element(nogfile$query, namelist) & is.element(nogfile$COG_category, cog.category)==TRUE)
}
```

# 5) Functional enrichment - input three data files
# 1. a genome info (.gff) from NCBI 
# 2. a DEG list: you can separate up- and down-regulated genes list
# 3. a functional category list generated from eggNOG
#    : # How to make "emapper.csv": Input the ".faa file" from NCBI (Download sequences in FASTA format for protein) into EggNOG (http://eggnogdb.embl.de/#/app/emapper)
```{r}
#read in your .gff file and list of significant genes here
my.gff <- as.data.frame(rtracklayer::import.gff(list.files(pattern = "\\.gff$")))
#my.gff <- as.data.frame(rtracklayer::import.gff("GCF_000007805.1_ASM780v1_genomic.gff"))
my.genes <- read.csv("DEGs_list.csv")

#execute function 
gff.table <- gff.parse(my.gff)
#convert from locus tags to GI accession numbers
my.accs <- gff.table[gff.table$locus_tag %in% my.genes$gene,]$acc
#check length
length(my.accs) == length(my.genes$gene)
my.genes[my.genes$gene %ni% gff.table$locus_tag,]
#These differentially expressed genes do not exist in the gff table
my.genes$gene[my.genes$gene %ni% gff.table$locus_tag]
#Gene function category
my.eggNOG <- read_csv(list.files(pattern = "*emapper.csv"))
```

# 5) Functional enrichment - run! 
```{r}
my.genome.NOGs <- getNOG(my.eggNOG)

#these genes were identified as differentially expressed, but are not present in the eggNOG database
gff.table[gff.table$acc %in% my.accs[my.accs %ni% my.genome.NOGs$query],]


#append unknown function annotation to proteins with missing COG classifications
my.genome.NOGs$COG_category[is.na(my.genome.NOGs$COG_category)] <- "S"
my.genome.NOGs$HMM_description[is.na(my.genome.NOGs$HMM_description)] <- "function unknown, manually assigned"
#calculate enrichment of all functional categories in the DEGs
my.genes.hypg <-  nogtest(my.accs, my.genome.NOGs, 1, cutoff = 1)
#correct for multiple testing, using FDR. 
my.genes.hypg$p.adj <- p.adjust(my.genes.hypg$probability, method = "fdr")
my.genes.hypg


#get proteins with specific function, where "X" is the single letter functional code
ls <- list()
counter <- 1
for (i in my.genes.hypg$COG_category){
  ls[[counter]] <- nogset(my.accs, my.genome.NOGs, i)
  counter <- counter +1
}
my.sig.proteins <- bind_rows(ls)
p.vals <- vector()
for (i in 1:length(my.sig.proteins$COG_category)) {
  cog <- my.sig.proteins$COG_category[i]
  p.vals[i] <- filter(my.genes.hypg, my.genes.hypg$COG_category == cog)$p.adj
}

#convert those proteins from acc back to locus_tags
my.sig.proteins$locus_tag <- gff.table$locus_tag[match(my.sig.proteins$query, gff.table$acc)]
my.sig.proteins$old_locus_tag <- gff.table$old_locus_tag[match(my.sig.proteins$locus_tag, gff.table$locus_tag)]
my.sig.proteins$log2FoldChange <- my.genes$log2FoldChange[match(my.sig.proteins$locus_tag, my.genes$gene)]
my.sig.proteins$COG.padj <- p.vals
(my.sig.proteins<- my.sig.proteins[c(5,6,1,4,2,3,7,8)])

#write out files
write_csv(my.sig.proteins, "Result_Function/_func.csv")

my.sig.proteins.filter <- my.sig.proteins %>%     # Sorted in ascending order by adjusted p-value
  filter(COG.padj < 0.05)
#write out files
write_csv(my.sig.proteins.filter, "Result_Function/_func_sig.csv")


#Bar graph
func <- data.frame(my.sig.proteins.filter)
query <- count(func, "COG_category")
query.data <- data.frame(query)
query.data$COG_category <- factor(query.data$COG_category, 
                                  level = query.data$COG_category[order(query.data$freq)])
myplot <- ggplot(query.data, aes(x=COG_category, y=freq)) + 
  geom_bar(stat = "identity") + 
  geom_text(aes(label=freq), vjust=0)
myplot

ggsave("Result_Function/_func_sig.png")
```



